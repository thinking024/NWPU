# 绪论

## 1.数据模型

- 概念模型：信息模型，主要用于数据库设计
- 逻辑模型：层次模型、网状模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型
- 物理模型：数据底层的存取



## 2.关系模型

- 关系：一张表
- 元组：表中的一行数据
- 码：表中的某个属性组，可以唯一确定一个元组
  - 候选码：某一属性或属性组的值能唯一的标识一个元组，而其任何子集都不能再标识
  - 主码：从多个候选码中选择一个
  - 主属性：候选码中包含的属性
  - 非主属性：未包含在候选码中的属性
- 域：属性的取值范围



## 3.三级模式

- 模式：逻辑模式，对数据库中全体数据的描述
- 外模式：用户模式，用户能够看见和使用的部分数据的描述
- 内模式：存储模式，数据物理结构和存储方式的描述



## 4.两层映像

- 外模式/模式映像
- 模式/内模式映像



# 关系数据库

## 1.关系操作

- 查询

  - 选择：选择行元素

  - 投影：选择表中的部分列，构成新表

  - 并

  - 差

  - 笛卡尔积

  - 连接

    - 等值连接：把两个表中的两个不同的列，选择值相等的元组

    - 自然连接：内连接，在等值连接的基础上，**去掉重复的列**，有些元组可能无法连接上，则舍弃掉（称为悬浮元组）
    - 外连接：与内连接不同，把左右两张表的悬浮元组都保留，根据需要填上空值
      - 左外连接：只保留左边表的悬浮元组
      - 右外连接：只保留右边表的悬浮元组

- 插入

- 删除

- 更新



## 2.关系完整性

- 实体完整性：主码非空
- 参照完整性：外键
- 用户定义完整性：not null、unique、check语句





## 3.范式

- 1NF：属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了，1NF 是所有关系型数据库的最基本要求
- 2NF：在 1NF 的基础之上，消除了非主属性对于码的部分函数依赖
- 3NF：在 2NF 的基础之上，消除了非主属性对于码的传递依赖
- BCNF：在3NF 的基础上消除主属性对于码的部分与传递函数依赖。



## 4.事务

逻辑上的一组数据库操作，要么都执行，要么都不执行，是一个不可分割的工作单位

### 4.1 ACID特性

- 原子性Atomicity：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用

- 一致性Consistency：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的

- 隔离性Isolation：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的

- 持久性Durability：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影



### 4.2 并发

多个事务并发执行，可能会破坏一致性Consistency、隔离性Isolation

#### 4.2.1 问题

- **脏读（Dirty read）:** 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。

- **丢失修改（Lost to modify）:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。	例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。

- **不可重复读（Unrepeatableread）:** 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的**修改**导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。

- **幻读（Phantom read）:** 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）**插入**了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。



#### 4.2.2 并发控制技术

- 封锁：mysql采用的方法之一
  - 排他锁/写锁：X索
  - 共享锁/读锁：S索
- 时间戳
- 乐观控制法
- 多版本并发控制MVCC：mysql采用的方法之一



#### 4.2.3 事务隔离级别

SQL 标准定义了四个隔离级别：

- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- **REPEATABLE-READ(可重复读)：**  对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

------

|     隔离级别     | 脏读 | 不可重复读 | 幻读 |
| :--------------: | :--: | :--------: | :--: |
| READ-UNCOMMITTED |  √   |     √      |  √   |
|  READ-COMMITTED  |  ×   |     √      |  √   |
| REPEATABLE-READ  |  ×   |     ×      |  √   |
|   SERIALIZABLE   |  ×   |     ×      |  ×   |